# dart

## 特性
* 虽然Dart是强类型语言，类型标注却是可选的，因为Dart可以推导类型。在以上的代码中， number 所推导的类型是 int。在你想要显式地说明无需设定类型， 使用特殊类型 dynamic.
* 不同于Java，Dart没有public, protected和 private这些关键字。 如果一个标识符以下划线(_)开头，它是对库私有的。详情请参见 库和可见性.
* 实例变量可以是 final ，但不能为 const。final实例变量必须在构造函数体开始之前进行初始化，通过构造函数参数在变量声明中或在构造函数的初始化程序列表中。
* 创建多行字符串的方式是使用三个单引号或三个双引号标记：
* var 声明的变量，不能在 const 字符串中使用.
* 条件判断的时候，必须是显式的检查值，而不是通过es中的隐式转换。
* 如果展开运算符右侧的表达式有可能为null，可通过使用可判空展开运算符(...?)来避免异常：
* 创建为运行时常量的集，在对象前添加const：
* 创建为编译时常量的映射，在映射字面量之前添加const，编译时候，如果被修改，会报错。`Uncaught Error: Unsupported operation: Cannot modify unmodifiable Map`
* 映射像列表一样支持展开运算符 (... 和 ...?) 及collection if 和 for。

## 类
* Dart是一个带有类和基于mixin继承的面向对象语言。每个对象都是类的实例，所有类都继承自 [Object.。* 基于mixin的继承* 表示虽然每个类（除Object外）都只有一个超类，一个类主体可在多个类级别中复用。
* 构造两个相同的编译时常量会产生单个相同的实例。
```js
var  a  =  const  ImmutablePoint(1,  1);
var  b  =  const  ImmutablePoint(1,  1);
assert(identical(a,  b));  // 它们是相同的实例！
```
* 关键字 const 在Dart 2的常量上下文成为可选。
* 要在运行时获取对象的类型，可以使用Object的 runtimeType 属性，它返回一个 Type 对象。
* 默认，子类中的构造函数调用超类中的未命名、无参数的构造函数。超类的构造函数在构造函数体的开头调用。如果还使用了 初始化程序列表，它在超类调用前执行。总之，执行的顺序如下：
  - 初始化程序列表initializer list
  - 超类的无参构造函数
  - 主类的无参构造函数
* 如果超类中没有未命名的无参构造函数，那么就必须手动调用超类的一个构造函数。在冒号(:)后、刚好在构造函数体前（如有）指定超类构造函数。
* Warning: 超类构造函数的参数无法访问 this。例如，参数可调用静态方法但无法调用实例方法。

### 初始化程序列表
* 重定向构造函数？？用途不明白
* 工厂构造函数无法访问 this。


### 抽象方法
* 实例、getter和setter方法可以是抽象的，定义接口并将其实现留给其它类。抽象方法仅能存在于 抽象类中。
* 要让方法为抽象的，使用分号 (:wink: 而非方法体：

### 重载成员
* 子类可重载实例方法、getters和setters。可以使用 `@override` 标注来表明你想要重载一个成员：、
* 可以重载下表中所显示的运算符。 `!=` 并不是一个可重载运算符。表达式 e1 != e2 只是针对 !(e1 == e2)的语法糖。

### 静态变量
* 静态变量直到使用时才进行初始化。

### 静态方法
* 静态方法（类方法）不对实例进行操作，因此无法访问 this。

## 泛型
* 如果你在查看基本数组类型List的 API 文档，实际上看到的类型是 List<E>。<…>标记表示 List是一种泛型（或参数化）类型 – 使用拥有正式类型参数的类型。[按照惯例，大部分类型变量都有单字母名称，如 E, T, S, K和 V。
* 使用带有构造函数的参数化类型在使用构造函数时要指定一个或多个类型，将类型放在类名后的尖括号 (<...>) 中。
* 泛型集合及它们所包含的类型 Dart的泛型是实化（reified）类型，表示它们可以在运行时携带类型信息。例如，可以测试一个集合的类型：
* 不同的是，Java中的泛型使用的是擦除（erasure）类型，表示泛型参数在运时会被删除。在 Java 中可以测试一个对象是否为List，但无法测试它是否为 List<String>。